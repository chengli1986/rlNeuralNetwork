package myRLBot;

import java.awt.*;
import java.awt.geom.*;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileWriter;

import robocode.AdvancedRobot;
import robocode.DeathEvent;
import robocode.WinEvent;
import robocode.BulletHitEvent;
import robocode.BulletMissedEvent;
import robocode.HitByBulletEvent;
import robocode.HitRobotEvent;
import robocode.HitWallEvent;
import robocode.BulletHitBulletEvent;
import robocode.RobotDeathEvent;
import robocode.ScannedRobotEvent;
import robocode.RoundEndedEvent;
import robocode.BattleEndedEvent;
import robocode.BattleResults;
import robocode.RobocodeFileOutputStream;
import robocode.RobocodeFileWriter;

public class MyRLBot extends AdvancedRobot {
	public static final double PI = Math.PI;
	private Target enemy;
	private LUT lut;
	private Train rlTrainer;
	private double imReward = 0.0;
	private double reward = 0.0;
	private double firePower;
	private short isHitWall = 0;
	private short isHitByBullet = 0;
	private int counter_hit=0;
	private int counter_fire=0;
	static double[] array = new double[100];
	static int roundCount =0;
	static int round = 0;

	public void run() {
		setBodyColor(Color.RED);
		setGunColor(Color.YELLOW);
		setRadarColor(Color.GREEN);
		
		lut = new LUT();
		load();
		rlTrainer = new Train(lut);
		enemy = new Target();
		enemy.distance = 1000;
		
		out.println("What: "+reward);
		
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		turnRadarRightRadians(2 * PI);
		
		while (true) {
			firePower = 300.0/enemy.distance;
			if (firePower > 3.0)
				firePower = 3.0;
			//setupRadarScan();
			setTurnRadarLeftRadians(2 * PI);
			setupGunMove();
			setupRobotMovement(firePower);
			/* give control back to robocode engine */
			execute();
		}
	}

	private void setupRobotMovement(double pwr) {
		
		int curState = getState();
		int curAction = rlTrainer.selectAction(curState);
		//double diff = rlTrainer.train(curState, curAction, imReward);
		double diff = rlTrainer.train(curState, curAction, reward);
		out.println("STATE="+curState+" REWARD="+reward+" DIFF="+diff);
		/*
		reward = reward + imReward;
		setDebugProperty("ImReward", " "+reward);
		
		imReward = 0.0;
		 */
		isHitWall = 0;
		isHitByBullet = 0;

		switch (curAction) {
			case Action.RobotAhead:
				setAhead(Action.RobotMoveDistance+Action.RobotMoveAddDistance);
				gunFire(pwr);
				break;
			case Action.RobotBack:
				setBack(Action.RobotMoveDistance+Action.RobotMoveAddDistance);
				gunFire(pwr);
				break;
			case Action.RobotAheadTurnLeft:
				setAhead(Action.RobotMoveDistance);
				setTurnLeft(Action.RobotTurnDegree);				
				gunFire(pwr);
				break;
			case Action.RobotAheadTurnRight:
				setAhead(Action.RobotMoveDistance);
				setTurnRight(Action.RobotTurnDegree);
				gunFire(pwr);
				break;
			case Action.RobotBackTurnLeft:
				setBack(Action.RobotMoveDistance);
				setTurnLeft(Action.RobotTurnDegree);				
        		gunFire(pwr);
        		break;
      		case Action.RobotBackTurnRight:
      			setBack(Action.RobotMoveDistance);
      			setTurnRight(Action.RobotTurnDegree);
        		gunFire(pwr);
        		break;
		}
	}

	private int getState() {
		int heading = State.getHeading(getHeading());
		int targetDistance = State.getTargetDistance(enemy.distance);
		int targetBearing = State.getTargetBearing(enemy.bearing);
		int energy = State.getEnergy(getEnergy());
		int state = State.stateTable[heading][targetDistance][targetBearing][isHitWall][isHitByBullet][energy];
		/* DEBUG
		setDebugProperty("heading", " "+heading);
		setDebugProperty("distance", " "+targetDistance);
		setDebugProperty("bearing", " "+targetBearing);
		setDebugProperty("state", " "+state);
		*/
		return state;
	}

  	private void gunFire(double pwr) {
  		if (getGunHeat() == 0)
  			setFire(pwr);
  	}
	
  	private void setupRadarScan() {
  		double radarOffset;
  		//Returns the direction that the robot's radar is facing, in radians. 
  		//The value returned will be between 0 and 2 * PI (is excluded).
  		// Note that the heading in Robocode is like a compass, 
  		//where 0 means North, PI / 2 means East, PI means South, and 3 * PI / 2 means West.
  		radarOffset = getRadarHeadingRadians() - (PI/2 - Math.atan2(enemy.y - getY(),enemy.x - getX()));
  		if (radarOffset > PI)
  			radarOffset -= 2*PI;
  		if (radarOffset < -PI)
  			radarOffset += 2*PI;
  		if (radarOffset < 0)
  			radarOffset -= PI/10;
  		else
  			radarOffset += PI/10;
  		// turn the radar
  		setTurnRadarLeftRadians(radarOffset);
  	}

    /** 
     * Move the gun to the predicted next bearing of the enemy.  
     */
  	private void setupGunMove() {
  		long time;
  		long nextTime;
  		Point2D.Double p;
  		p = new Point2D.Double(enemy.x, enemy.y);
  		for (int i = 0; i < 20; i++) {
  			nextTime = (int)Math.round((getRange(getX(),getY(),p.x,p.y)/(20-(3*firePower))));
  			time = getTime() + nextTime - 10;
  			p = enemy.guessPosition(time);
  		}
  		//offsets the gun by the angle to the next shot based on linear targeting provided by the enemy class
  		double gunOffset = getGunHeadingRadians() - (PI/2 - Math.atan2(p.y - getY(),p.x -  getX()));
  		setTurnGunLeftRadians(normaliseBearing(gunOffset));
  	}

  	/**
     * If a bearing is not within the -pi to pi range, 
     * alters it to provide the shortest angle.
     * @param angle The original angle.
     * @return The shortest angle.
     */
  	double normaliseBearing(double ang) {
  		if (ang > PI)
  			ang -= 2*PI;
  		if (ang < -PI)
  			ang += 2*PI;
  		return ang;
  	}

    /**
     * Returns the distance between two x,y coordinates.
     * @param x1 First x.
     * @param y1 First y.
     * @param x2 Second x.
     * @param y2 Second y.
     * @return The distance between (x1, y1) and (x2, y2).
     */
  	public double getRange( double x1,double y1, double x2,double y2 ) {
  		double xo = x2 - x1;
  		double yo = y2 - y1;
  		double h = Math.sqrt( xo * xo + yo * yo );
  		return h;
  	}

  	public void onBulletHit(BulletHitEvent e) {
  		// big reward when hitting the target
  		//double change = 1 * e.getBullet().getPower();
  		//imReward += change;
  		counter_hit++;
  		//setDebugProperty("onBulletHit", " "+change);
  	}

  	public void onBulletHitBullet(BulletHitBulletEvent e) {
  		// this means bad which I am on the target line of enemy...
  		//double change = (-1) * e.getBullet().getPower();
  		//imReward += change;
  		//setDebugProperty("onBulletHitBullet", " "+change);
  	}

  	public void onBulletMissed(BulletMissedEvent e) {
  		//double change = -e.getBullet().getPower();
  		//imReward += change;
  		//setDebugProperty("onBulletMissed", " "+change);
  	}

  	public void onHitByBullet(HitByBulletEvent e) {
  		/*
  		double power = e.getBullet().getPower();
  		double change = 0.0;
  		if (power <= 1)
  			change = (-1) * (4 * power);
  		else
  			change = (-1) * (4 * power + 2 * (power - 1));
  		imReward += change;
  		isHitByBullet = 1;
  		setDebugProperty("onHitByBullet", " "+change);
  		*/
  	}

  	public void onHitRobot(HitRobotEvent e) {
  		/*
  		double change = -0.6 * 1;
  		imReward += change;
  		setDebugProperty("onHitRobot", " "+change);
  		*/
  	}

  	public void onHitWall(HitWallEvent e) {
  		/*
  		double change = (-1) * (Math.abs(getVelocity()) * 0.5 - 1);
  		imReward += change;
  		isHitWall = 1;
  		setDebugProperty("onHitWall", " "+change);
  		*/
  	}

  	public void onScannedRobot(ScannedRobotEvent e) {
  		if ((e.getDistance() < enemy.distance)||(enemy.name == e.getName())) {
  			double absbearing_rad = (getHeadingRadians() + e.getBearingRadians()) % (2 * PI);  			
  			double h = normaliseBearing(e.getHeadingRadians() - enemy.head);
  			h = h/(getTime() - enemy.ctime);
  			enemy.changehead = h;
  			enemy.x = getX()+Math.sin(absbearing_rad)*e.getDistance(); 
  			enemy.y = getY()+Math.cos(absbearing_rad)*e.getDistance(); 
  			enemy.bearing = e.getBearingRadians();
  			enemy.head = e.getHeadingRadians();
  			enemy.name = e.getName();
  			enemy.ctime = getTime();
  			enemy.speed = e.getVelocity();
  			enemy.distance = e.getDistance();
  			enemy.energy = e.getEnergy();
  		}
  	}

  	public void onRobotDeath(RobotDeathEvent e) {
  		/* init distance back to largest */
  		enemy.distance = 1000;
  	}

  	public void onWin(WinEvent event) {
  		reward = 5.0;
  		save();
		//array[roundCount]=(double)counter_hit/counter_fire;
		//System.out.println(array[roundCount]);
		roundCount++;
		round++;
		//System.out.println("DEBUG win number:" + roundCount);
		System.out.println(">>> Reward: " + reward);
  	}

  	public void onDeath(DeathEvent event) {
  		reward = -5.0;
  		save();
  		// array[roundCount]=(double)counter_hit/counter_fire;
  		// System.out.println(array[roundCount]);
  		//roundCount++;
  		System.out.println(">>> Reward: " + reward);
  	}

  	public void load() {
  		out.println(">>> load LUT");
  		try {
  			lut.loadFile(getDataFile("data.txt"));
  		} catch (Exception e) {
  		}
  	}

  	public void save() {
  		out.println(">>> save LUT");
  		try {
  			lut.saveFile(getDataFile("data.txt"));
  		} catch (Exception e) {
  			out.println("Exception trying to write: " + e);
  		}  
  	}
    /*
  	public void onBattleEnded (BattleEndedEvent e) {
  		BattleResults result =e.getResults();
  		PrintStream s = null;
	  
  		RobocodeFileOutputStream writer = null;
  		try {
  			s = new PrintStream(new RobocodeFileOutputStream(getDataFile("score.txt")));
  			// writer = new RobocodeFileOutputStream(getDataFile("score.txt"));
  			s.println("Score                "+result.getScore());;
  			s.println("Survival             "+result.getSurvival());;
  			s.println("Bullet Damage        "+result.getBulletDamage());;
  			s.println("Bullet Damage Bonus  "+result.getBulletDamageBonus());;
  			s.println("Ram Damage           "+result.getRamDamage());;
  			s.println("Ram Damage Bonus     "+result.getRamDamageBonus());;
  			s.close(); 
  		} catch ( IOException a) {
  		} finally {
  			try {
  				if ( writer != null)
  					writer.close( );
  			} catch ( IOException a) {
  			
  			}
  		}
	  
  		PrintStream w = null;
  		try {
  			w = new PrintStream(new RobocodeFileOutputStream(getDataFile("win.txt")));
  			for( int i = 0; i<array.length;i++)
  				w.println(array[i]);
  			w.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		} 
  	}
  	*/
  	
  	public void onRoundEnded(RoundEndedEvent event) {
  		RobocodeFileWriter fw = null;
  		try {
  			fw = new RobocodeFileWriter("/Users/chwlo/Documents/workspace/EECE592/bin/chengBot/ChengBot.data/reward.txt",true);
  			//fw.write("reward: "+(int)reward+"\n");
  			fw.write((int)reward+"\n");
  			fw.flush();
  			fw.close(); 
  		} catch ( IOException e) {
  			System.out.println("IOException trying to write: " + e);
  		} finally {
  			try {
  				if ( fw != null)
  					fw.close( );
  			} catch ( IOException e) {
  				System.out.println("Exception trying to close witer: " + e);
  				e.printStackTrace();
  			}
  		}
  	} 
}